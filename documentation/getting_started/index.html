<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta name="generator" content="Bootply" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<link rel=icon href=/content/images/favicon.ico>
		<title>Oakton - Getting Started</title>
		<link href="/oakton/content/bootstrap.min.css" rel="stylesheet" type="text/css" />
		<link href="/oakton/content/prism.css" rel="stylesheet" type="text/css" />
		<link href="/oakton/content/theme.css" rel="stylesheet" type="text/css" />




        <link rel="apple-touch-icon" href="/bootstrap/img/apple-touch-icon.png">
        <link rel="apple-touch-icon" sizes="72x72" href="/bootstrap/img/apple-touch-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="114x114" href="/bootstrap/img/apple-touch-icon-114x114.png">

        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" />

        <!-- CSS code from Bootply.com editor -->
        <link href="/oakton/content/affix.css" rel="stylesheet" type="text/css" />
    </head>

    <!-- HTML code from Bootply.com editor -->

    <body  >


        <nav class="navbar navbar-default navbar-fixed-top" role="banner">
		  <div class="container">
		    <div class="navbar-header">
		      <a href="/oakton" class="navbar-brand">Oakton</a>
		    </div>
		    <nav class="collapse navbar-collapse" role="navigation">
		      <ul class="nav navbar-nav pull-right">
		        <li>
		          <a href="/oakton/documentation/getting_started">Getting Started</a>
		        </li>
		        <li>
		          <a href="/oakton/documentation">Documentation</a>
		        </li>
		        <li>
		        <li>
<a href="https://gitter.im/jasperfx/oakton?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/jasperfx/oakton" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a>
		        </li>
		      	<li><a href="/oakton/documentation" title="Documentation">Previous</a></li>
		      	<li><a href="/oakton/documentation/commands" title="Commands">Next</a></li>
		      </ul>
		      <div class="navbar-form navbar-left" role="search">
		        <div class="form-group">
		          <input id="search" type="search" class="form-control" placeholder="Search">
		        </div>
		      </div>

		    </nav>

		  </div>
		</nav>

		  <div class="container">
		  	<nav class="navbar-inverse">
		  		<ol class="breadcrumb"><li><a href="/oakton/">Oakton</a></li><li><a href="/oakton/documentation">Documentation</a></li><li class="active">Getting Started</li></ol>
		  	</nav>
		  </div>

		<!--main-->
		<div class="container">
			<div class="row">
		      <!--left-->

		      <div class="col-md-3" id="leftCol">
		      	<h3>Oakton 1.3.0</h3>
		      	<br />

				<ul class="nav nav-stacked affix" id="sidebar">

		        </ul>

		        	<h3 class="no-margin">Next</h3><p><a href="/oakton/documentation/commands">Commands</a></p>
		        	<h3 class="no-margin">Previous</h3><a href="/oakton/documentation">Documentation</a></p>

		        </ul>
		      </div><!--/left-->

		      <!--right-->
		      <div class="col-md-9">
			      	<h1>Getting Started<a href="https://github.com/jasperfx/oakton/blob/master/documentation/documentation/getting_started.md"  class="text-muted small pull-right" style="margin-top: 10px"><i class="fa fa-github"></i> Edit on GitHub</a></h1>

			      	<hr />

			      	<div id="main-pane">
			      		<!--title: Getting Started-->
<p>Oakton originated in the now defunct <a href="https://github.com/DarthFubuMVC/fubucore">FubuCore</a> project in 2010 as a mechanism to allow our .Net
development team to build robust console line utilities with these attributes:</p>
<ul>
<li>Make it easy to embed and expose command help for user friendliness</li>
<li>Be consistent with Unix/Linux command line idioms from arguments and optional names -- i.e., make the command line usage
feel like git's command line syntax</li>
<li>Easily enable tools to expose multiple commands</li>
<li>Completely separate the command line parsing from the actual functionality of the console application <em>which we
still believe separates Oakton from most other existing command line argument parsing tools in the .Net space</em></li>
<li>Enable relatively easy testing of the command line tools</li>
<li>Validate user input and helpfully tell them when it's invalid and what the correct usage should be</li>
</ul>
<p>Oakton was originally extracted from FubuCore as a new standalone project before adding some new improvements and support for Netstandard targets and the new fangled
CoreCLR.</p>
<h2 id="your-first-command">Your First Command</h2>
<p>To get started, simply create a new dotnet console application and add the <code>Oakton</code> nuget dependency. For your first commnd, let's start simple with a command that will simply print out a specified name with an optional color and title. The logical first step is to just
create the input class for your command that will establish the arguments and an optional flag:</p>
<pre><code class="language-csharp">&#xA;public class NameInput&#xA;{&#xA;    [Description(&quot;The name to be printed to the console output&quot;)]&#xA;    public string Name { get; set; }&#xA;    &#xA;    [Description(&quot;The color of the text. Default is black&quot;)]&#xA;    public ConsoleColor Color { get; set; } = ConsoleColor.Black;&#xA;    &#xA;    [Description(&quot;Optional title preceeding the name&quot;)]&#xA;    public string TitleFlag { get; set; }&#xA;}&#xA;</code></pre>
<p>You'll note that I've added some <code>[Description]</code> attributes strictly for the purpose of adding user help messages that we'll take a look at later. Now that we've got that out of the way, let's create our first command:</p>
<pre><code class="language-csharp">&#xA;[Description(&quot;Print somebody&#x27;s name&quot;)]&#xA;public class NameCommand : OaktonCommand&lt;NameInput&gt;&#xA;{&#xA;    public NameCommand()&#xA;    {&#xA;        // The usage pattern definition here is completely&#xA;        // optional&#xA;        Usage(&quot;Default Color&quot;).Arguments(x =&gt; x.Name);&#xA;        Usage(&quot;Print name with specified color&quot;).Arguments(x =&gt; x.Name, x =&gt; x.Color);&#xA;    }&#xA;&#xA;    public override bool Execute(NameInput input)&#xA;    {&#xA;        var text = input.Name;&#xA;        if (!string.IsNullOrEmpty(input.TitleFlag))&#xA;        {&#xA;            text = input.TitleFlag &#x2B; &quot; &quot; &#x2B; text;&#xA;        }&#xA;        &#xA;        // This is a little helper in Oakton for getting&#xA;        // cute with colors in the console output&#xA;        ConsoleWriter.Write(input.Color, text);&#xA;&#xA;&#xA;        // Just telling the OS that the command&#xA;        // finished up okay&#xA;        return true;&#xA;    }&#xA;}&#xA;</code></pre>
<p>With that in place, let's wire it up to our applications <code>Program.Main()</code>:</p>
<pre><code class="language-csharp">&#xA;class Program&#xA;{&#xA;    static int Main(string[] args)&#xA;    {&#xA;        // As long as this doesn&#x27;t blow up, we&#x27;re good to go&#xA;        return CommandExecutor.ExecuteCommand&lt;NameCommand&gt;(args);&#xA;    }&#xA;}&#xA;</code></pre>
<p>Now, from the command line, I'll just try <code>dotnet run</code>, which will give us this (slightly elided) output complaining
that we're missing a required argument or two:</p>
<pre><code>Invalid usage

 Usages for 'name' (Print somebody's name)

  ----------------------------------------------------------------------------------------
    Usages
  ----------------------------------------------------------------------------------------
                      Default Color -&gt;  name &lt;name&gt; [-t, --title &lt;title&gt;]
    Print name with specified color -&gt;  name &lt;name&gt; Black|DarkBlue|DarkGreen|DarkCyan|DarkRed|DarkMagenta|DarkYellow|Gray|DarkGray|Blue|Green|Cyan|Red|Magenta|Yellow|White [-t, --title &lt;title&gt;]
  ----------------------------------------------------------------------------------------

  ----------------------------------------------------------------------------------------
    Arguments
  ----------------------------------------------------------------------------------------
     name -&gt; The name to be printed to the console output
    color -&gt; The color of the text. Default is black
  ----------------------------------------------------------------------------------------

  ----------------------------------------------------------------------------------------
    Flags
  ----------------------------------------------------------------------------------------
    [-t, --title &lt;title&gt;] -&gt; Optional title preceeding the name
  ----------------------------------------------------------------------------------------
</code></pre>
<p>Do note that we could get the same output without the angry &quot;Invalid Usage&quot; message by:</p>
<pre><code>dotnet run -- help
</code></pre>
<p>or</p>
<pre><code>dotnet run -- ?
</code></pre>
<p>Now, to actually run the command, try:</p>
<pre><code>dotnet run -- &quot;Alex Smith&quot;
</code></pre>
<p>Which will simply print out <em>Alex Smith</em> to the console output. We had to wrap the text in quotations so that Oakton treated
the full name with spaces as a single argument.</p>
<div class="alert-info alert"><p><strong>Note!</strong>
The &quot;--&quot; argument shown in the samples here is only a construct of using the &quot;dotnet run&quot; command to separate arguments that should
apply to the dotnet tool on the left from arguments that should be passed into our application. If you run the compiled application
itself, you will not need the &quot;--&quot; separator.</p>
</div>
<p>To print the name in blue, we can type <code>dotnet run -- &quot;Alex Smith&quot; Blue</code>. To add a title, we can use the signature <code>dotnet run -- &quot;Alex Smith&quot; --title Mr</code> or <code>dotnet run -- &quot;Alex Smith&quot; --t Mr</code> to get the output &quot;Mr Alex Smith.&quot;</p>
<h2 id="how-it-works">How it Works</h2>
<p>Oakton is attempting to take the tokenized values in the command line input and apply the values to the matching fields or properties
on the input class objects before passing that object into the proper command's <code>Execute()</code> method. Oakton also validates that the
signature and flag usage matches the known command syntax.</p>
<h2 id="multiple-commands-in-one-tool">Multiple Commands in One Tool</h2>
<p>Now, let's move on to building a tool with multiple commands. Let's say that we're trying to partially recreate
the git command line with the <code>clean</code> and <code>checkout</code> commands:</p>
<pre><code class="language-csharp">&#xA;[Description(&quot;Switch branches or restore working tree files&quot;)]&#xA;public class CheckoutCommand : OaktonCommand&lt;CheckoutInput&gt;&#xA;{&#xA;    public override bool Execute(CheckoutInput input)&#xA;    {&#xA;        return true;&#xA;    }&#xA;}&#xA;&#xA;[Description(&quot;Remove untracked files from the working tree&quot;)]&#xA;public class CleanCommand : OaktonCommand&lt;CleanInput&gt;&#xA;{&#xA;    public override bool Execute(CleanInput input)&#xA;    {&#xA;        return true;&#xA;    }&#xA;}&#xA;</code></pre>
<p>In the <code>Program.Main()</code>, the setup is just a little bit different to go discover all the commands held in the application:</p>
<pre><code class="language-csharp">&#xA;static int Main(string[] args)&#xA;{&#xA;    var executor = CommandExecutor.For(_ =&gt;&#xA;    {&#xA;        // Find and apply all command classes discovered&#xA;        // in this assembly&#xA;        _.RegisterCommands(typeof(Program).GetTypeInfo().Assembly);&#xA;    });&#xA;&#xA;    return executor.Execute(args);&#xA;}&#xA;</code></pre>
<p>Now then, typing <code>dotnet run</code> without specifying a valid command will give you this:</p>
<pre><code>  ------------------------------------------------------------------
    Available commands:
  ------------------------------------------------------------------
    checkout -&gt; Switch branches or restore working tree files
       clean -&gt; Remove untracked files from the working tree
  ------------------------------------------------------------------
</code></pre>
<p>Typing <code>dotnet run -- help</code> or <code>dotnet run -- ?</code> would give you the same information.</p>
<p>Our fake <code>clean</code> command has this usage:</p>
<pre><code class="language-csharp">&#xA;public class CleanInput&#xA;{&#xA;    [Description(&quot;Do it now!&quot;)]&#xA;    public bool ForceFlag { get; set; }&#xA;    &#xA;    [FlagAlias(&#x27;d&#x27;)]&#xA;    [Description(&quot;Remove untracked directories in addition to untracked files&quot;)]&#xA;    public bool RemoveUntrackedDirectoriesFlag { get; set; }&#xA;    &#xA;    [FlagAlias(&#x27;x&#x27;)]&#xA;    [Description(&quot;Remove only files ignored by Git&quot;)]&#xA;    public bool DoNoUseStandardIgnoreRulesFlag { get; set; }&#xA;}&#xA;</code></pre>
<p>To see the specific usage of the <code>clean</code> command, try <code>dotnet run -- help clean</code> or <code>dotnet run -- ? clean</code> to get the usage:</p>
<pre><code> Usages for 'clean' (Remove untracked files from the working tree)
  clean [-f, --force] [-d, --remove-untracked-directories] [-x, --do-no-use-standard-ignore-rules]

  -------------------------------------------------------------------------------------------
    Flags
  -------------------------------------------------------------------------------------------
                              [-f, --force] -&gt; Do it now!
       [-d, --remove-untracked-directories] -&gt; Remove untracked directories in addition to untracked files
    [-x, --do-no-use-standard-ignore-rules] -&gt; Remove only files ignored by Git
  -------------------------------------------------------------------------------------------
</code></pre>
<p>From here, you probably want to learn more about:</p>
<ul>
<li><a href="/oakton/documentation/commands">All about commands</a></li>
<li><a href="/oakton/documentation/arguments">Using arguments and argument signatures</a></li>
<li><a href="/oakton/documentation/flags">Optional Flags</a></li>
<li><a href="/oakton/documentation/help">How the help output works</a></li>
<li><a href="/oakton/documentation/opts">&quot;Opts&quot; Files</a></li>
</ul>

			      	</div>

			      	<hr />

			      	<nav>
				        <span>
				        	<strong>Previous: </strong><a href="/oakton/documentation">Documentation</a>

				        </span>
				        <span class="pull-right">

				        	<strong>Next: </strong><a href="/oakton/documentation/commands">Commands</a>

				        </span>
			      	</nav>

		      </div><!--/right-->
		  	</div><!--/row-->
		</div><!--/container-->

<script type='text/javascript' src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>
$('#search').keyup(function(e){
  if(e.keyCode == 13) {
    var search = $('#search').val();

    var url = 'https://www.google.com/#q=site:http://jasperfx.github.io/oakton ' + search;
    url = encodeURI(url);

    //alert(url);

    window.location.href = url;

    e.stopPropagation();
    if (e.cancelBubble!=null) e.cancelBubble = true;
    return false;
  }



});

</script>
    </body>


    <foot>
        <script type='text/javascript' src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
        <script type='text/javascript' src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

        <script type="text/javascript" src="/oakton/content/embed.js"></script>
        <script type="text/javascript" src="/oakton/content/prism.js"></script>
        <script type="text/javascript" src="/oakton/content/sidebar.js"></script>
        <script type="text/javascript" src="/oakton/content/affix.js"></script>
    </foot>
</html>
